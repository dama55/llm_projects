<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LLM (OpenAI Compatible Stream)</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    #status { margin-top: 12px; font-weight: bold; }
    #output { margin-top: 20px; padding: 10px; border: 1px solid #ccc; max-height: 520px; overflow-y: auto; }
    .card { margin-bottom: 18px; border-bottom: 1px solid #eee; padding-bottom: 12px; }
    .prompt { color: blue; font-weight: bold; white-space: pre-wrap; }
    .response { color: green; white-space: pre-wrap; }
    .think-toggle { margin-top: 8px; }
    .think-box { margin-top: 8px; padding: 8px; border: 1px solid #ddd; background: #fafafa; white-space: pre-wrap; }
    .hidden { display: none; }
    .error { color: red; white-space: pre-wrap; }
    textarea { width: 100%; min-height: 80px; }
    button { margin-right: 8px; }
  </style>
</head>
<body>
  <h1>LLM Stream Output（OpenAI互換）</h1>

  <form id="generate-form">
    <label for="prompt">Prompt:</label><br/>
    <textarea id="prompt" name="prompt" required></textarea><br/>
    <button type="submit" id="generate-btn">Generate</button>
    <button type="button" id="stop-btn">Stop</button>
    <button type="button" id="clear-btn">Clear</button>
  </form>

  <div id="status"></div>
  <div id="output"></div>

  <script>
    // DOM要素を取得
    const form = document.getElementById("generate-form");
    const output = document.getElementById("output");
    const status = document.getElementById("status");
    const btn = document.getElementById("generate-btn");
    const stopBtn = document.getElementById("stop-btn");
    const clearBtn = document.getElementById("clear-btn");
    const promptBox = document.getElementById("prompt");

    // 生成中断用（fetchをabortする）
    let aborter = null;

    // 状態表示の更新
    function setStatus(t) { status.textContent = t; }

    // 画面に「prompt」「response欄」「think欄」を追加する
    function appendCard(prompt) {
      const card = document.createElement("div");
      card.className = "card";

      const p = document.createElement("div");
      p.className = "prompt";
      p.textContent = `Prompt: ${prompt}`;
      card.appendChild(p);

      const toggle = document.createElement("button");
      toggle.type = "button";
      toggle.className = "think-toggle hidden";
      toggle.textContent = "思考を表示";
      card.appendChild(toggle);

      const think = document.createElement("div");
      think.className = "think-box hidden";
      think.textContent = "";
      card.appendChild(think);

      toggle.addEventListener("click", () => {
        const hidden = think.classList.toggle("hidden");
        toggle.textContent = hidden ? "思考を表示" : "思考を非表示";
      });
      
      const r = document.createElement("div");
      r.className = "response";
      r.textContent = "";
      card.appendChild(r);
      


      output.appendChild(card);

      output.scrollTop = output.scrollHeight;
      return { responseEl: r, thinkEl: think, thinkToggleEl: toggle };
    }

    // SSEは「イベントブロック」が \n\n 区切りで届くので、バッファを分割する
    function splitSSEBlocks(buffer) {
      const parts = buffer.split("\n\n");
      return { blocks: parts.slice(0, -1), rest: parts[parts.length - 1] };
    }

    // SSEの1ブロックから "data:" 行だけを取り出し、連結して返す（SSE仕様）
    function extractData(block) {
      return block
        .split("\n")
        .filter(line => line.startsWith("data:"))
        .map(line => line.slice(5).trimStart())
        .join("\n");
    }

    // Qwen系の <think>...</think> を「回答」「思考」に分離する
    function createThinkSplitter() {
      const OPEN = "<think>";
      const CLOSE = "</think>";
      const openKeep = OPEN.length - 1;
      const closeKeep = CLOSE.length - 1;

      return {
        inThink: false,
        carry: "",
        push(chunk) {
          this.carry += chunk;
          let answer = "";
          let thinking = "";

          while (this.carry.length > 0) {
            if (this.inThink) {
              const closeIdx = this.carry.indexOf(CLOSE);
              if (closeIdx >= 0) {
                thinking += this.carry.slice(0, closeIdx);
                this.carry = this.carry.slice(closeIdx + CLOSE.length);
                this.inThink = false;
                continue;
              }
              // 閉じタグの途中一致に備えて末尾だけ保持
              const safeLen = Math.max(0, this.carry.length - closeKeep);
              thinking += this.carry.slice(0, safeLen);
              this.carry = this.carry.slice(safeLen);
              break;
            }

            const openIdx = this.carry.indexOf(OPEN);
            if (openIdx >= 0) {
              answer += this.carry.slice(0, openIdx);
              this.carry = this.carry.slice(openIdx + OPEN.length);
              this.inThink = true;
              continue;
            }

            // 開始タグの途中一致に備えて末尾だけ保持
            const safeLen = Math.max(0, this.carry.length - openKeep);
            answer += this.carry.slice(0, safeLen);
            this.carry = this.carry.slice(safeLen);
            break;
          }

          return { answer, thinking };
        },
        flush() {
          // 終了時に残っている文字列をモードに応じて返す
          const tail = this.carry;
          this.carry = "";
          if (this.inThink) {
            this.inThink = false;
            return { answer: "", thinking: tail };
          }
          return { answer: tail, thinking: "" };
        }
      };
    }

    // メイン処理：OpenAI互換の /v1/chat/completions を stream=true で叩く
    async function run(prompt) {
      // もし前の生成が走っていたら中断
      if (aborter) aborter.abort();
      aborter = new AbortController();

      // 表示領域を作る
      const card = appendCard(prompt);
      const responseEl = card.responseEl;

      setStatus("生成中…");
      btn.disabled = true;

      // OpenAI互換のリクエストJSON（gateway側でmodel補完やsystem挿入をするので最小でもOK）
      const body = {
        stream: true, // ストリームで返してもらう
        messages: [
          { role: "user", content: prompt }
        ],
        temperature: 0.7,
        top_p: 0.9,
        max_tokens: 2500,
        // ★追加：Qwen3のthinking切替（vLLMのReasoning Outputs機能）
        // chat_template_kwargs: { enable_thinking: false },
      };
      const thinkSplitter = createThinkSplitter();

      try {
        // fetchでPOST（EventSourceはGETしかできないので使わない）
        const res = await fetch("/v1/chat/completions", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
          signal: aborter.signal
        });

        // HTTPエラーならエラー扱い
        if (!res.ok) {
          const t = await res.text();
          throw new Error(`HTTP ${res.status}: ${t}`);
        }

        // StreamのReaderを取る
        const reader = res.body.getReader();
        const decoder = new TextDecoder("utf-8");

        // SSEは途中で切れて届くので、文字列バッファを持つ
        let buf = "";

        while (true) {
          // チャンクを読む
          const { value, done } = await reader.read();
          if (done) break;

          // bytes -> text に変換（stream:trueで途中でもデコード）
          buf += decoder.decode(value, { stream: true });

          // SSEイベント単位に分割
          const { blocks, rest } = splitSSEBlocks(buf);
          buf = rest;

          for (const block of blocks) {
            const data = extractData(block);
            if (!data) continue;

            // OpenAI互換の終了合図
            if (data === "[DONE]") {
              const tail = thinkSplitter.flush();
              if (tail.answer) responseEl.textContent += tail.answer;
              if (tail.thinking) {
                card.thinkEl.textContent += tail.thinking;
                card.thinkToggleEl.classList.remove("hidden");
              }
              setStatus("完了");
              btn.disabled = false;
              aborter = null;
              return;
            }

            // 通常はJSONなのでパースして delta.content を取り出す
            try {
              const obj = JSON.parse(data);
              const delta = obj.choices?.[0]?.delta?.content ?? "";
              if (delta) {
                const piece = thinkSplitter.push(delta);
                if (piece.answer) responseEl.textContent += piece.answer;
                if (piece.thinking) {
                  card.thinkEl.textContent += piece.thinking;
                  card.thinkToggleEl.classList.remove("hidden");
                }
              }
            } catch (e) {
              // 万一JSONでないデータが混ざったら、そのまま表示（保険）
              const piece = thinkSplitter.push(data);
              if (piece.answer) responseEl.textContent += piece.answer;
              if (piece.thinking) {
                card.thinkEl.textContent += piece.thinking;
                card.thinkToggleEl.classList.remove("hidden");
              }
            }

            // 自動スクロール
            output.scrollTop = output.scrollHeight;
          }
        }

        // 最後の取りこぼし（think外のみ）を反映
        const tail = thinkSplitter.flush();
        if (tail.answer) responseEl.textContent += tail.answer;
        if (tail.thinking) {
          card.thinkEl.textContent += tail.thinking;
          card.thinkToggleEl.classList.remove("hidden");
        }

        // ここまで来たら一応完了扱い
        setStatus("完了");
      } catch (e) {
        // 途中中断（abort）はエラー表示しない方が自然なので分ける
        if (String(e).includes("AbortError")) {
          setStatus("停止");
        } else {
          setStatus("エラー");
          responseEl.className = "error";
          responseEl.textContent += "\n" + String(e);
        }
      } finally {
        btn.disabled = false;
        aborter = null;
      }
    }

    // フォーム送信（Generate）
    form.addEventListener("submit", (e) => {
      e.preventDefault();
      const prompt = promptBox.value.trim();
      if (!prompt) return;
      run(prompt);
    });

    // Stopボタン：進行中のfetchを中断
    stopBtn.addEventListener("click", () => {
      if (aborter) aborter.abort();
      aborter = null;
      btn.disabled = false;
      setStatus("停止");
    });

    // Clearボタン：表示を消す
    clearBtn.addEventListener("click", () => {
      if (aborter) aborter.abort();
      aborter = null;
      output.innerHTML = "";
      setStatus("");
      btn.disabled = false;
    });

    // Enterで送信 / Shift+Enterで改行
    promptBox.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        form.requestSubmit();
      }
    });
  </script>
</body>
</html>
